**Day 15:** Bianry Trees & BST Implementation.

Create a Node class that has properties for the value stored in the node, the left child node, and the right child node. Create a Binary Tree class and define a method for each of the depth first traversals: pre-order, in-order,
post-order which returns an array of the values, ordered appropriately. Any exceptions or errors that come from your code should be semantic, capture-able errors.

Create a Binary Search Tree class: This class should be a sub-class of the Binary Tree Class, with the following additional methods: Add, Arguments: value, Return: nothing, Adds a new node with that value in the correct location in the binary search tree. Contains - Argument: value, and returns: boolean indicating whether or not the value is in the tree at least once.

- [Tree Whiteboard](/assets/tree.png)
- [Tree Solution](Trees.js)

**Day 16:** Max Value

We write the following method extending the tree class for the Binary Tree class: Find maximum value; Arguments: none, Returns: number. Find the maximum value stored in the tree. You can assume that the values stored in the Binary Tree will be numeric.

- [Find Maximum Value Whiteboard](/assets/MaxValue.png)
- [Tree Solution](Trees.js)

**Day 17:** Breadth First

We write a function called Breadth first that returns a list of all values in the tree, in the order they were encountered. We traverse the tree using a breadth first approach.

- [Breadth First Whiteboard](/assets/breadth-first.png)
- [Tree Solution](Trees.js)

---
[Back](/README.md)

---
